# Описание
Описание функций
> void init_queue(queue *q) - инициализируем очередь, задаем нулевые указатели и нулевой размер \
> int size_queue(queue *q) - возвращает размер очереди \
> bool empty_queue(queue *q) - проверка на пустоту очереди \
> void push_back(queue *q, int value) - добавление элемента спереди \
> int pop_front(queue *q) - удаление элемента сзади \
> int top_front_(queue *q) - функция выводящая значение последнего элемента без его удаления(в принципе нахуй не нужна, я в итоге не воспользовался ею) \
> void deleteQueue(queue *q) - функция очистки всей очереди \
> void printQueue(queue *q) - функция вывода очереди 

структура каждого элемента очереди, он ссылается на некст элемент и имеет собственное значение
> typedef struct element { \
    int value; //значение \
    struct element *next; //указ на след элемент \
} element; 

Структура самой очереди, она хранит указатель на первый элемент, последний и размер
> typedef struct queue { \
    element *first; //первый элемент \
    element *last; //последний элемент \
    int size; //рамзер \
} queue;

`insertion_sort` - функция сортировки вставкой. прям самая типичная сортировка как в википедии

Makefile (запуск программы)
> тут короче все просто
>- пишешь сначала `make` и у тебя компилируется вся программа со всем необхимым 
>-затем ты пишешь `make run` и у тебя запускается программа
> также есть и другие команды
>- `make clean` - удаляет все исполняемые файлы, то есть *.out
>- `make cmp` - компилирует указанный файл
>- `make debug` - дебаг
> CC = gcc - компилятор \
> CFLAGS = -std=c99 -Wall -Werror - флаги \
> DEBUG = gdb - компилятор gdb \
> FILEOUT = queue.out -исполняемый файл \
> SOURCES = queue.c main.c -файл основной программы(main.c) и файла библиотеки очереди(queue.c)
