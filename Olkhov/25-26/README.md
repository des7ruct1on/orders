# Описание
Описание функций
> void init_queue(Queue *q) - инициализируем очередь, задаем нулевые указатели и нулевой размер \
> size_t size_queue(Queue *q) - возвращает размер очереди \
> bool empty_queue(Queue *q) - проверка на пустоту очереди \
> void push_back(Queue *q, Item value) - добавление элемента спереди \
> int pop_front(Queue *q) - удаление элемента сзади \
> int top_front_(Queue *q) - функция выводящая значение последнего элемента без его удаления(в принципе нахуй не нужна, я в итоге не воспользовался ею) \
> void deleteQueue(Queue *q) - функция очистки всей очереди \
> void printQueue(Queue *q) - функция вывода очереди 

структура каждого элемента очереди, он ссылается на некст элемент и имеет собственное значение
> typedef struct _node_queue { \
    Item value; //значение \
    struct _node_queue *next; //указ на след элемент \
} NodeQ; 

Структура самой очереди, она хранит указатель на первый элемент, последний и размер
> typedef struct _queue { \
    NodeQ *first; //первый элемент \
    NodeQ *last; //последний элемент \
    int size; //рамзер \
} Queue;

`bubble_sort` - функция сортировки вставкой. прям самая типичная сортировка как в википедии \
Алгоритм сортировки
>-Начнем с начала очереди (q->first) и будем проходить по всем элементам до конечного элемента (lptr).
>-Сравниваем текущий элемент (ptr1) с его следующим соседом (ptr1->next).
>-Если текущий элемент больше следующего, меняем их местами.
>-Продолжаем этот процесс до тех пор, пока не достигнем конечного элемента (lptr).
>-После первого прохода, самый большой элемент "всплывет" в конец.
>-Уменьшаем lptr, так как самый большой элемент уже находится на своем месте.
>-Повторяем шаги с 1 по 6 до тех пор, пока не произойдет полный проход без каких-либо обменов. Это означает, что очередь отсортирована.

Makefile (запуск программы)
> тут короче все просто
>- пишешь сначала `make` и у тебя компилируется вся программа со всем необхимым 
>-затем ты пишешь `make run` и у тебя запускается программа
> также есть и другие команды
>- `make clean` - удаляет все исполняемые файлы, то есть *.out
>- `make cmp` - компилирует указанный файл
>- `make debug` - дебаг
> CC = gcc - компилятор \
> CFLAGS = -std=c99 -Wall -Werror - флаги \
> DEBUG = gdb - компилятор gdb \
> FILEOUT = queue.out -исполняемый файл \
> SOURCES = queue.c main.c -файл основной программы(main.c) и файла библиотеки очереди(queue.c)
